#include <Wire.h>
#include <Adafruit_GFX.h>
#include <D:\Teensy\PlayDice\Adafruit_SSD1306.h>
#include "ClockHandler.h"


#define OLED_RESET 4
Adafruit_SSD1306 display(OLED_RESET);

#define LED 13
#define TEMPOPIN 9
#define DACPIN 40
#define CLOCKPIN 0

int bpm = 120;                  // beats per minute of sequence (assume sequence runs in eighth notes for now)
int minBPM = 35;				// minimum BPM allowed for internal/external clock
int maxBPM = 300;				// maximum BPM allowed for internal/external clock
int seqStep = 0;                // increments each step of sequence
elapsedMillis timeCounter = 0;  // millisecond counter to check if next sequence step is due
int voltsMin = 0;               // Minimum allowed voltage amt per step
int voltsMax = 5;               // Maximum allowed voltage amt
int tempoPot = 512;				// Reading from tempo potentiometer for setting bpm

//	Variables for managing clock input for externally setting tempo
ClockHandler clock(minBPM, maxBPM);
int clockInput = 0;				// Reading from clock input
int clockThreshold = 500;		// Clock is converted to value between 0 and 1023 for 0-3.3V - set threshold to converted level
int clockHigh = 0;				// Set to 1 if clock is above threshold
unsigned long lastClockHigh = 0;// time in milliseconds since clock last high to check for bounce
unsigned long clockHighTime = 0;// time in milliseconds of last clock signal
unsigned long clockInterval = 0;// time in milliseconds of current clock interval
int clockBPM = 0;				// BPM read from external clock
int clockSignal = 0;			// 1 = External clock is sending currently sending pulses

int btnUp = 12;                 // switch 12 used for parameter up push button
int paramUp = 0;                // Parameter up button: 1 if pressed
unsigned long lastParamUp = 0;  // time in milliseconds since Param button pressed to check for bounce
int btnDn = 11;                 // switch 11 used for parameter down push button
int paramDn = 0;                // Parameter down button: 1 if pressed
unsigned long lastParamDn = 0;  // time in milliseconds since Param button pressed to check for bounce

elapsedMillis debugCounter = 0;

struct Step {
	float volts;
	int rand_amt; // from 0 to 10
	int type;
	int subdiv;
};

struct Sequence {
	int type;     //  Sample and Hold, gated etc
	int steps;    //  Number of steps in sequence
	int portamento : 1;  // bit for portamento true false
	struct Step Steps[8];
};

enum seqType { CV, GATE, PITCH };
struct Sequence seq;

const unsigned char diceBitmap[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xCF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x3C, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x7E, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x7E, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x1C, 0x7C, 0x07, 0xC0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0xFE, 0x00, 0xF0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x07, 0x1F, 0x80, 0x7C, 0x7C, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xEE, 0x0E, 0x1F, 0x80, 0x00, 0xFC, 0x08, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x03, 0x9C, 0x0F, 0x8F, 0x00, 0xFC, 0x28, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0xF0, 0xF9, 0xF1, 0x80, 0x1F, 0x80, 0x10, 0xC8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0F, 0x81, 0xFC, 0x70, 0xF0, 0x1F, 0x8C, 0x01, 0x88, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x7C, 0x01, 0xFC, 0x38, 0x1E, 0x0F, 0x1F, 0x03, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0xE0, 0x01, 0xF0, 0x1F, 0x83, 0xC0, 0x1F, 0x86, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x07, 0xC0, 0x7C, 0x1F, 0x0C, 0xD0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x38, 0x7E, 0x00, 0x03, 0xE3, 0xE0, 0x0F, 0x00, 0x19, 0xD0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x60, 0xFE, 0x00, 0x07, 0xF1, 0xE0, 0x03, 0xF0, 0x39, 0xD0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x68, 0xFE, 0x00, 0x07, 0xE0, 0x70, 0x00, 0x7C, 0x31, 0xB0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x2C, 0x30, 0x00, 0x03, 0xC3, 0x30, 0x00, 0x0E, 0x03, 0xA0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x26, 0x00, 0xF0, 0x00, 0x1E, 0x10, 0x00, 0x00, 0x09, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x23, 0x03, 0xF8, 0x00, 0xF0, 0x10, 0x00, 0x00, 0xD8, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x31, 0x83, 0xF8, 0x07, 0x80, 0x10, 0x00, 0x00, 0xD8, 0x60, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x30, 0xC3, 0xF0, 0x3C, 0x07, 0x90, 0x00, 0x00, 0xB8, 0x60, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x60, 0x01, 0xE0, 0x0F, 0x90, 0x00, 0x00, 0xBB, 0x60, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x10, 0x30, 0x0F, 0x00, 0x0F, 0x90, 0x00, 0x01, 0xB3, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x7C, 0x00, 0x1F, 0x90, 0x00, 0x01, 0x87, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x08, 0xE0, 0x00, 0x1F, 0x10, 0x00, 0x01, 0x87, 0xC0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x00, 0x0C, 0x00, 0x0E, 0x10, 0x00, 0x01, 0x06, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x02, 0x3C, 0x00, 0x00, 0x10, 0x00, 0x01, 0x01, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x08, 0x42, 0x3E, 0x00, 0x00, 0x10, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0C, 0xE3, 0x7E, 0x00, 0x00, 0x10, 0x00, 0x03, 0x43, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0C, 0xE3, 0x7E, 0x00, 0x00, 0x10, 0x00, 0x02, 0x66, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x04, 0xF3, 0x7C, 0x00, 0x00, 0x10, 0x00, 0x02, 0xE4, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x04, 0x73, 0x78, 0x07, 0x00, 0x10, 0x00, 0x02, 0xEC, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x06, 0x71, 0x00, 0x0F, 0x80, 0x10, 0x00, 0x02, 0xD8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x06, 0x71, 0x00, 0x0F, 0x80, 0x18, 0x00, 0x06, 0xD0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x02, 0x01, 0x80, 0x1F, 0x80, 0x18, 0x03, 0x84, 0xB0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0x01, 0x80, 0x1F, 0x01, 0x98, 0x07, 0xC4, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x81, 0x80, 0x1F, 0x03, 0xD8, 0x07, 0xE4, 0x60, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x0E, 0x07, 0xDC, 0x03, 0xE4, 0xC0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x80, 0x00, 0x07, 0xDF, 0x03, 0xE4, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x60, 0x80, 0x00, 0x0F, 0xDB, 0xE1, 0xE9, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x20, 0x80, 0x00, 0x0F, 0x98, 0x7C, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x30, 0xC0, 0x00, 0x07, 0x18, 0x0F, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x43, 0x80, 0x00, 0x70, 0x03, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x08, 0x47, 0xC0, 0x01, 0xE0, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0C, 0x4F, 0xC0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x06, 0x4F, 0xC0, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x06, 0x4F, 0x81, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x2F, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void setup() {
	pinMode(LED, OUTPUT);

	analogWriteResolution(12);    // set resolution of DAC pin for outputting variable voltages
	pinMode(btnUp, INPUT_PULLUP);
	pinMode(btnDn, INPUT_PULLUP);

	//  Setup sequence
	seq.type = CV;
	seq.steps = 8;
	seq.Steps[0].volts = 5;
	seq.Steps[1].volts = 4;
	seq.Steps[1].rand_amt = 0;
	seq.Steps[2].volts = 3;
	seq.Steps[3].volts = 2;
	seq.Steps[3].rand_amt = 0;
	seq.Steps[4].volts = 0;
	seq.Steps[5].volts = 4;
	seq.Steps[6].volts = 3;
	seq.Steps[7].volts = 2;

	// Setup OLED - by default, generate the high voltage from the 3.3v line internally
	display.begin(SSD1306_SWITCHCAPVCC, 0x3C);  // initialize with the I2C addr 0x3C (for the 128x64)
	display.display();
	display.clearDisplay();
	display.drawPixel(10, 10, WHITE);
	display.display();
	Serial.print(SSD1306_LCDHEIGHT);

	display.setTextSize(2);
	display.setTextColor(WHITE);
}

void loop() {
	//	read value of clock signal if present and set bmp accordingly
	clockInput = analogRead(CLOCKPIN);
	if (clockInput > clockThreshold) {
		// check if a new clock pulse has been detected - previous state low and no high clock in the last 20 milliseconds ( && millis() - lastClockHigh > 20 last test causing some false readings so maybe ditch)
		if (clockHigh == 0 && millis() - lastClockHigh > 20) {
			//	Eurorack clock fires 16 5V pulses per bar
			clockInterval = millis() - clockHighTime;
			clockBPM = (1 / (((double)(millis() - clockHighTime) / 1000) * 4)) * 60;
			clockHighTime = millis();
			clockSignal = 1;

			Serial.println("High");
		}
		clockHigh = 1;
		lastClockHigh = millis();
	}
	else {
		clockHigh = 0;
	}
	//	check if clock signal has fired in the last second
	if (millis() - clockHighTime > 1000) {
		clockSignal = 0;
	}

	//	Debug missing clock signals
	if (debugCounter > 2) {
		debugCounter = 0;
		
		if (clockBPM >= minBPM && clockBPM < maxBPM && clockSignal) {
			Serial.print("Clock ");
		}
		else {
			Serial.print("XXXXX ");
		}
		
		Serial.print(" in: ");
		Serial.print(clockInput);
		Serial.print("  ms: ");
		Serial.print(millis());
		Serial.print("  bpm: ");
		Serial.println(clockBPM);

	}

	//  read value of potentiometer to set speed
	tempoPot = analogRead(TEMPOPIN);

	// work out whether to get bpm from tempo potentiometer or clock signal (checking that we have recieved a recent clock signal)
	if (clockBPM >= minBPM && clockBPM < maxBPM && clockSignal) {
		bpm = clockBPM;
	} else	{
		bpm = map(tempoPot, 0, 1023, minBPM, maxBPM);        // map(value, fromLow, fromHigh, toLow, toHigh)
	}



	
	// check if time to move to new step
	unsigned int timeStep = 1000 / (((float) bpm / 60) * 2);

	//	check if the sequence counter is ready to advance to the next step. Also if using external clock wait for pulse
	if (timeCounter >= timeStep &&  millis() - clockHighTime - 10 >= clockInterval) {

		// calculate possible ranges of randomness to ensure we don't try and set a random value out of permitted range
		float randLower = constrain(seq.Steps[seqStep].volts - ((double)seq.Steps[seqStep].rand_amt / 2), 0, 10);
		float randUpper = constrain(seq.Steps[seqStep].volts + ((double)seq.Steps[seqStep].rand_amt / 2), 0, 10);
		float randAmt = randLower + ((double)rand() / (double)RAND_MAX) * (randUpper - randLower);

		if (0 && seq.Steps[seqStep].rand_amt > 0) {
			Serial.print("volts: ");
			Serial.println(seq.Steps[seqStep].volts);
			Serial.print("rand: ");
			Serial.println(seq.Steps[seqStep].rand_amt);

			Serial.print("lower: ");
			Serial.println(randLower);
			Serial.print("upper: ");
			Serial.println(randUpper);

			Serial.print("result: ");
			Serial.println(randAmt);
			Serial.println("");
		}

		setCV(randAmt);

		if (seqStep % 2 == 0) {
			digitalWrite(LED, HIGH);
		}
		else {
			digitalWrite(LED, LOW);
		}

		timeCounter = 0;
		seqStep += 1;
		if (seqStep == seq.steps) {
			seqStep = 0;
		}

		Serial.print("Frame start: "); Serial.println(millis());
		display.clearDisplay();
		display.setCursor(0, 0);
		display.setTextSize(1);
		display.setTextColor(WHITE);
		display.print("bpm: ");
		display.println(bpm);
		////display.print("millis: ");
		////display.println(millis());
		//display.display();
		//display.clearDisplay();
		display.drawBitmap(0, 0, diceBitmap, 128, 64, WHITE);
		display.display();
		Serial.print("Frame end: "); Serial.println(millis());
	}

	//  Parameter button handler
	if (digitalRead(12)) {
		paramUp = 0;
	}
	else {
		//  check if button has been pressed (previous state off and over x milliseconds since last on)
		if (paramUp == 0 && millis() - lastParamUp > 10) {
			if (seq.Steps[0].volts < voltsMax) {
				seq.Steps[0].volts += 1;
			}
			Serial.println("Param up");
		}
		paramUp = 1;
		lastParamUp = millis();
	}
	if (digitalRead(11)) {
		paramDn = 0;
	}
	else {
		//  check if button has been pressed (previous state off and over x milliseconds since last on)
		if (paramDn == 0 && millis() - lastParamDn > 10) {
			if (seq.Steps[0].volts > voltsMin) {
				seq.Steps[0].volts -= 1;
			}
			Serial.println("Param down");
		}
		paramDn = 1;
		lastParamDn = millis();
	}




}

void setCV(float setVolt) {
	//  DAC buffer takes values of 0 to 4095 relating to 0v to 3.3v
	//  setVolt will be in range 0 - voltsMax (5 unless trying to do pitch which might need negative)
	float dacVolt = setVolt / voltsMax * 4095;
	analogWrite(DACPIN, (int)dacVolt);

}


